---
title: "ITIS Taxonomic Validation and Re-Classification"
author: "Jaxine Wolfe and Katherine Qi"
date: "7/28/2019"
output: html_document
---

This project uses an R Markdown file (ITIS_Validation.Rmd) modified from [GitHub: WoRMs namespace_validation](https://github.com/klqi/EDI-NES-LTER-2019/tree/master/namespace_validation) to resolve, validate, and re-classify given prey species.It generates an output .csv file with the original, corrected, and classified information, using the ITIS database (primary) or NCBI (secondary). 

## R Markdown
```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)

library(tidyverse)
library(taxize)
library(plyr)
library(dplyr)
# library(tcltk)
```

## Setup

Input requirements: CSV table with all species names in a column "preytype_validated"

```{r}
# local development only
rm(list=ls())

my_path <- "/Users/jaxinewolfe/Documents/Research/PEP/NESLTER/Data/LlopizLab/Abundance/itis_validation"
setwd(my_path)

```


## Define Helper Functions used in Script 

```{r}

# wrapper function to call taxize get_tsn function and put resolved id into appropriate column
acquire_id <- function(resolved_name, counter, man.data) {
  # get taxomonic serial number for the given name
  response <- taxize::get_tsn(
    resolved_name,
    searchtype = 'scientific',
    accepted = TRUE,
    ask = FALSE,
    messages = FALSE
  )
  # check if name was able to return an id from itis
  response <- as.data.frame(response)
  if (!empty(response)) {
    # tandardize resolved name to retrieve id
    resolved_name <- gsub(" ", ".", resolved_name, fixed=TRUE)
    resolved_name <- gsub("-", ".", resolved_name, fixed=TRUE)
    # Pull highest order taxon id
    resolved_id <- response$ids
    # populate resolved_id_fromgnr
    man.data$resolved_id_fromgnr[counter] <<- resolved_id
  } # else leaves columns with original NA values
}

# wrapper function to call id2name and classification
# retrieves taxon info based on id and bins taxa into specified categories
id2taxoninfo <- function(tsn, counter, man.data) {
  # populate taxon_level 
  taxon_level <- unlist(id2name(tsn, db = 'itis')[[1]]$rank)
  # alt option: unlist(tax_rank(tsn, db='itis', rows=1))
  man.data$taxon_level_fromid[counter] <<- taxon_level
  # populate taxon_name
  taxon_name <- unlist(id2name(tsn, db = 'itis')[[1]]$name)
  man.data$taxon_name_fromid[counter] <<- taxon_name
  # populate taxon_bins
  hierarchy <- as.data.frame(classification(tsn, db='itis', rows=1)[[1]])

  # get genus, order, class, and phylum from hierarchy
  genus <- hierarchy$name[hierarchy$rank == "genus"]
  order <- hierarchy$name[hierarchy$rank == "order"]
  class <- hierarchy$name[hierarchy$rank == "class"]
  phylum <- hierarchy$name[hierarchy$rank == "phylum"]
  
  # check which of the main groups the taxa falls under and assign bins
  if (!identical(character(0), class) && class == "Appendicularia") {
      man.data$taxon_bins[counter] <<- "Appendicularian"
  } else if (!identical(character(0), order) && order == "Amphipoda") {
      man.data$taxon_bins[counter] <<- "Amphipod"
  } else if (!identical(character(0), order) && order == "Euphausiacea") {
      man.data$taxon_bins[counter] <<- "Krill"
  } else if (!identical(character(0), phylum) && phylum == "Chaetognatha") {
      man.data$taxon_bins[counter] <<- "Chaetognath"
  } else if (!identical(character(0), order) && order == "Calanoida") {
      if (!identical(character(0), genus) && genus == "Centropages") {
      man.data$taxon_bins[counter] <<- "Centropages"
      } else if (!identical(character(0), genus) && genus == "Calanus") {
       man.data$taxon_bins[counter] <<- "Calanus"
      } else {
        man.data$taxon_bins[counter] <<- "Other Calanoids"
      }
  } else {
      man.data$taxon_bins[counter] <<- "Other"
    }
  # set data_source column if original name could not be resolved through gnr 
  # man.data$data_source[counter] <<- "ITIS"
}

# helper function to fill in information for unclassifiable preytypes
edge_case <- function(name, counter) {
  if(name == "Fish Remains"|
     name == "Other"| name == "Unknown Soft" | 
     name == "Parasite" | is.na(name)) {
    man.data$data_source[counter] <<- "OCB"
    man.data$taxon_bins[counter] <<- toString(name)
    return(TRUE)
  }
  return(FALSE)
}

```

## ITIS Validation For Loop

```{r, echo=FALSE, include=FALSE}

# load preytype data
man.data <- read_csv("Llopiz_preytypes.csv")
# NOTE: manually added a preytype_validated column for ease of GNR

# add necessary column names and populate with NA 
man.data$resolved_names <- NA_character_
man.data$resolved_id_fromgnr <- NA_character_
man.data$data_source <- NA_character_
man.data$taxon_level_fromid <- NA_character_
man.data$taxon_name_fromid <- NA_character_
man.data$taxon_bins <- NA_character_
man.data$name_match <- FALSE

# reorder columns
man.data[,c("Llopiz_preytypes", "preytype_validated", "resolved_names", "resolved_id_fromgnr", "data_source", "taxon_level_fromid", "taxon_name_fromid", "taxon_bins", "name_match")] 

# set counter
counter <- 1
# loop through all rows
for (row in 1:nrow(man.data)) {
  # first check if name is an edge case
  if (edge_case(man.data$preytype_validated[counter], counter)) {
    # skip to next row if true
    counter <- counter + 1
    next
  }
  # try to resolve the name with gnr
  temp <- gnr_resolve(names = as.vector(man.data$preytype_validated[counter]), 
                      canonical = T, best_match_only = T, 
                      preferred_data_sources = c(3, 4)) 
  # 9 = worms
  # 4 = ncbi
  # 3 = itis
  # hardcoded from data sources: https://resolver.globalnames.org/data_sources
  
  # set primary data source
  primary_ds <- "ITIS"
  
  # Case: If gnr was able to resolve the name 
  if (!empty(temp)) {
    # populate resolved_names column
    gnr_name <- unlist(temp[1, 'matched_name2'])
    man.data$resolved_names[counter] <- gnr_name
    # populate data_source column
    authority <- unlist(temp[1, 'data_source_title'])
    # if the authority agrees with the primary_ds, populate with primary source
    if (authority == primary_ds) {
      man.data$data_source[counter] <- authority
    } else {
      # if the gnr source was not ITIS, populate with alternative source
      man.data$data_source[counter] <- authority
      man.data$resolved_names[counter] <- gnr_name
    }
    
    # Use aquire_id to populate resolved_id_fromgnr using the gnr_name
    acquire_id(gnr_name, counter, man.data)
    # use id2taxoninfo to poplate taxon_level_fromid, taxon_name_fromid, and taxon_bins
    id2taxoninfo(man.data$resolved_id_fromgnr[counter], counter, man.data)

    # check if taxon name matches with resolved
    if (man.data$taxon_name_fromid[counter] == man.data$resolved_names[counter]) {
      # set name_match to true
      man.data$name_match[counter] <- TRUE
    }
    } else { 
      # Case: GNR was unable to resolve by name, fill with NA
      man.data$resolved_names[counter] <- NA_character_
      }
  counter <- counter + 1
  print(counter) # print progress
}

# convert to csv file 
write.csv(man.data, file.path("Llopiz_resolved.csv"), row.names = FALSE)

# isolate taxa classified as other to fact check
Llopiz_other <- man.data %>% filter(taxon_bins == "Other")

```
