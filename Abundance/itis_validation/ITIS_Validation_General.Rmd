---
title: "ITIS_validation"
author: "Katherine Qi and Jaxine Wolfe"
date: "7/28/2019"
output: html_document
---

namespace_validation: This project uses an R Markdown file (ITIS_validation.Rmd) to resolve and re-classisy given taxonomic groups to the ITIS database (primary) or NCBI (secondary). It generates an output csv file with the original and corrected information that can be manually edited for name space development for further analysis.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(taxize)
library(plyr)
library(dplyr)
# library(tcltk)
```

## R Markdown
Set up taxonomy table built from inputted data set 
Run functions first to be able to use them in script (last chunk)- clean up later

Input requirements:
csv table with all species names in a column "name" and their corresponding ids in a column "tsn_id"

```{r}
# local development only
rm(list=ls())

# man.data <- read.csv(file.choose())
# man.data <- read.csv(tk_choose.files(caption = "Choose a .csv file to validate"))

my_path <- "/Users/jaxinewolfe/Documents/Research/PEP/NESLTER/Data/LlopizLab/Abundance/itis_validation"
setwd(my_path)

noaa_data <- read_csv("classify_NOAA_sample.csv")
unique(noaa_data)

```


# helper functions used in script 
```{r}

# wrapper function to call taxize get_tsn function and put resolved id into appropriate column
acquire_id <- function(resolved_name, counter, man.data) {
  # get taxomonic serial number for the given name
  response <- taxize::get_tsn(
    resolved_name,
    searchtype = 'scientific',
    accepted = FALSE,
    ask = FALSE,
    messages = FALSE
  )
  # check if name was able to return an id from itis
  response <- as.data.frame(response)
  if (!empty(response)) {
    # standardize resolved name to retrieve id
    resolved_name <- gsub(" ", ".", resolved_name, fixed=TRUE)
    resolved_name <- gsub("-", ".", resolved_name, fixed=TRUE)
    # Pull highest order taxon id
    resolved_id <- response$ids
    # populate resolved_id_fromgnr
    man.data$resolved_id_fromgnr[counter] <<- resolved_id
  } # else leaves columns with original NA values
  else{
    man.data$resolved_id_fromgnr[counter] <<- NA_character_
  }
}

# wrapper function to call id2name and...retrieves taxon info based on id: level, name, and higher order 
id2taxoninfo <- function(tsn, counter, man.data) {
  # populate taxon_level 
  taxon_level <- unlist(id2name(tsn, db = 'itis')[[1]]$rank)
  # alt option: unlist(tax_rank(tsn, db='itis', rows=1))
  man.data$taxon_level_fromid[counter] <<- taxon_level
  # populate taxon_name
  taxon_name <- unlist(id2name(tsn, db = 'itis')[[1]]$name)
  man.data$taxon_name_fromid[counter] <<- taxon_name
  # populate taxon_bins
  hierarchy <- as.data.frame(classification(tsn, db='itis', rows=1)[[1]])

  # get genus, order, class, and phylum
  genus <- hierarchy$name[hierarchy$rank == "genus"]
  order <- hierarchy$name[hierarchy$rank == "order"]
  class <- hierarchy$name[hierarchy$rank == "class"]
  phylum <- hierarchy$name[hierarchy$rank == "phylum"]
  
  # check which of the main groups the taxa falls under and assign bins
  if (!identical(character(0), class) && class == "Appendicularia") {
      man.data$taxon_bins[counter] <<- "Appendicularian"
  } else if (!identical(character(0), order) && order == "Amphipoda") {
      man.data$taxon_bins[counter] <<- "Amphipod"
  } else if (!identical(character(0), order) && order == "Euphausiacea") {
      man.data$taxon_bins[counter] <<- "Krill"
  } else if (!identical(character(0), phylum) && phylum == "Chaetognatha") {
      man.data$taxon_bins[counter] <<- "Chaetognath"
  } else if (!identical(character(0), order) && order == "Calanoida") {
      if (!identical(character(0), genus) && genus == "Centropages") {
      man.data$taxon_bins[counter] <<- "Centropages"
      } else if (!identical(character(0), genus) && genus == "Calanus") {
       man.data$taxon_bins[counter] <<- "Calanus"
      } else {
        man.data$taxon_bins[counter] <<- "Other Calanoids"
      }
  } else {
      man.data$taxon_bins[counter] <<- "Other"
    }
  # sets data_source column if original name could not be resolved through gnr 
  # man.data$data_source[counter] <<- "ITIS"
}

# helper function to fill in information for abiotic classes
edge_case <- function(name, counter) {
  if(name == "Fish Remains"|
     name == "Other"| name == "Unknown Soft" | 
     name == "Parasite" | is.na(name)) {
    man.data$data_source[counter] <<- "OCB"
    man.data$taxon_bins[counter] <<- toString(name)
    return(TRUE)
  }
  return(FALSE)
}

```

## Revamping the for loop
```{r, echo=FALSE, include=FALSE}

man.data <- read_csv("classify_NOAA_sample.csv")

# Resolve names 
counter <- 1
# column names 
man.data$resolved_names <- NA_character_
man.data$resolved_id_fromgnr <- NA_character_
man.data$data_source <- NA_character_
man.data$taxon_level_fromid <- NA_character_
man.data$taxon_name_fromid <- NA_character_
man.data$taxon_bins <- NA_character_
man.data$name_match <- FALSE

# reorder columns
man.data[,c("NOAA_Number", "NOAA_Identifier", "resolved_names", "resolved_id_fromgnr", "data_source", "taxon_level_fromid", "taxon_name_fromid", "taxon_bins", "name_match")] 

# loop through all rows
for (row in 1:nrow(man.data)) {
  # first check if name is abiotic
  if (edge_case(man.data$NOAA_Identifier[counter], counter)) {
    # skip to next row if true
    counter <- counter + 1
    next
  }
  # Then try to resolve the name with gnr
  temp <- gnr_resolve(names = as.vector(man.data$NOAA_Identifier[counter]), 
                      canonical = T, best_match_only = T, 
                      preferred_data_sources = c(3, 4)) 
  # 9 = worms
  # 4 = ncbi
  # 3 = itis
  # hardcoded from data sources: https://resolver.globalnames.org/data_sources
  
  # set primary data source
  primary_ds <- "ITIS"
  
  # Case: If gnr was able to resolve the name 
  if (!empty(temp)) {
    # populate resolved_names column
    gnr_name <- unlist(temp[1, 'matched_name2'])
    man.data$resolved_names[counter] <- gnr_name
    # populate data_source column
    authority <- unlist(temp[1, 'data_source_title'])
    # if the authority agrees with the primary_ds, populate with primary source
    if (authority == primary_ds) {
      man.data$data_source[counter] <- authority
    } else {
      # if the gnr source was not ITIS, populate with alternative source
      man.data$data_source[counter] <- authority
      man.data$resolved_names[counter] <- gnr_name
    }
    
    # Use aquire_id to populate resolved_id_fromgnr using the gnr_name
    acquire_id(gnr_name, counter, man.data)
    # use id2taxoninfo to poplate taxon_level_fromid, taxon_name_fromid, and taxon_bins
    if (!is.na(man.data$resolved_id_fromgnr[counter])) {
      id2taxoninfo(man.data$resolved_id_fromgnr[counter], counter, man.data)
      # check if taxon name matches with resolved
      if (man.data$taxon_name_fromid[counter] == man.data$resolved_names[counter]) {
      # set name_match to true
      man.data$name_match[counter] <- TRUE
    }
    } else {
      counter <- counter + 1
      next
    }
    } else { 
      # Case: GNR was unable to resolve by name, fill with NA
      man.data$resolved_names[counter] <- NA_character_
      }
  counter <- counter + 1
  print(counter)
}

# convert to csv file 
write.csv(man.data, file.path("NOAA_resolved.csv"), row.names = FALSE)

# isolate taxa classified as other to fact check
# Llopiz_other <- man.data %>% filter(taxon_bins == "Other")

```
